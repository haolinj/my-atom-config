'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.sweep = sweep;
exports.nonReduxDispatch = nonReduxDispatch;

var _jsan = require('jsan');

var _difference = require('lodash/difference');

var _difference2 = _interopRequireDefault(_difference);

var _omit = require('lodash/omit');

var _omit2 = _interopRequireDefault(_omit);

var _actionTypes = require('../constants/actionTypes');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function sweep(state) {
  return _extends({}, state, {
    actionsById: (0, _omit2.default)(state.actionsById, state.skippedActionIds),
    stagedActionIds: (0, _difference2.default)(state.stagedActionIds, state.skippedActionIds),
    skippedActionIds: [],
    currentStateIndex: Math.min(state.currentStateIndex, state.stagedActionIds.length - 1)
  });
}

function nonReduxDispatch(store, message, instanceId, action, initialState, preInstances) {
  if (message !== 'DISPATCH') return initialState;
  var instances = preInstances || store.getState().instances;
  if (!instances.options[instanceId].lib === 'redux') return initialState;
  var state = instances.states[instanceId];

  switch (action.type) {
    case 'TOGGLE_ACTION':
      return (0, _jsan.stringify)(state);
    case 'JUMP_TO_STATE':
      return (0, _jsan.stringify)(state.computedStates[action.index].state);
    case 'ROLLBACK':
      return (0, _jsan.stringify)(state.computedStates[0].state);
    case 'SWEEP':
      store.dispatch({ type: _actionTypes.SET_STATE, newState: sweep(state) });
      return undefined;
    default:
      return undefined;
  }
}